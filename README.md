## ECE241-project-game-of-squares

|                                              |                                          |
|:---------------------------: | --------------------------------------------------------------|                         
|Project Title               | game of squares                                                 |
|Date                        | December 2, 2017                                                |   
|<p>Group Members<br>(Name  Student Number)</p>| <p>Tianyi(Nora) Xu  1003130809<br> Chenhao Liu 1002996332 </p>|


### 1.0 Introduction

The goal of this project is to implement a classic board game called “game of squares”. This game is played on a 3x3 rectangular grid consisting of cells that are initially black. When a cell on the board is selected, its adjacent cells and itself will be flipped to the opposite color. The objective is to fill all the cells with white. 

Our primary motivation is to learn and explore how games were made in the old days. We tried to make our project challenging by adding all the aspects that a traditional game had. To understand how analog and digital conversion in audio, we added a background music and sound effects. To improve user experience, we implemented the display on VGA and user input on a PS2 keyboard.


### 2.0 Description of the Design

This project contains three sub-modules, which are display, audio and keyboard. In each subsection, the functionality and the connections between these modules will be explained in detail. The data flow of the project is: when the inputs are generated by the player, the decoder in the keyboard module will decode the signals into five 1-bit signals and feeds them into the display module and the audio module. The Finite State Machines inside the display and audio module will then manipulate the datapath such that it produces different sets of data to the controllers. The controller will transmit the data to the Audio CODEC chip and the video memory of the screen and the digital signals will be converted into various sound effects and displays.

#### 2.1 Display

The display module consists of two parts: the vga_inputs module(Appendix A) and the VGA adapter module. They are responsible for converting instructions of the player to the video memory of the screen. The finite state machine in the vga_inputs module manipulates the datapath to produce values of inputs for X, Y, and plot at different states. After receiving the inputs, the VGA adapter updates the video memory of the screen and the data inside the memory is displayed through a monitor.

<p align="center">
<img src=/images/figure1.png>
</p>
<p align="center">Figure 1. VGA adapter and input logic
</p>

#### 2.2 Audio

The Audio module is divided into three components: the bgm_inputs module(Appendix B), the se_inputs module(Appendix C) and the Audio Controller module. First, the source file is stored into a memory chip in its analog format through the process of sampling. After that, the bgm_inputs module and the se_inputs module provides the sequences of the samples at a specific frequency that coincides with the sample rate. Upon receiving the addition of the sound outputs, the audio controller transmits the data serially to the audio chip and the data is fed directly to the DACs. DACs further converts the numbers into analog voltage which can drive the headphones.

 
<p align="center">Figure 2. Audio Controller and input logic
</p>

#### 2.3 Keyboard

The keyboard module is used to communicate with a PS2 keyboard. Its main functionality is to translate user inputs into a set of outputs. They are fed directly into the audio and display module. This module consists of a decoder, two registers and a PS2 controller. The PS2 controller provides an interface to the PS/2 protocol, handling the data transmission and the timing control. As the enable signal is sent by the PS2 controller, the last data and the second last data are captured and used by the decoder to generate five 1-bit outputs, which then become the inputs to the audio and the display module.

<p align="center">Figure 3. PS2 Keyboard Controller
</p>

### 3.0  Report on Success
●	Display 
○	The start display depicts the title, “Game of Squares”, every time the game is launched or restarted
                   
<p align="center">Figure 4.  Start Display
</p>

○	The instruction page explains the mapping of softkeys 
                 
<p align="center">Figure 5. Instruction Page
</p>

○	The end display depicts “Game clear” when the game is cleared
        
<p align="center">Figure 6. End Display
</p>

○	Display the correct information when the square is selected and the move is confirmed
<p align="center">Figure 7.  Active Screen
</p>

●	Audio 
○	Sound effects as softkeys are pressed
○	A background music
●	PS2 keyboard control
○	‘WASD’-control: used to change the position of the cursor. W, A, S, and D maps to up, down, left, and right, respectively. 
○	Enter key: used to change the colour of the box currently selected.


### 4.0 Reflection

This project was generally well planned. However, improvements could still be made if we were going to start over again. Originally, we made the decision to use 1 bit per channel to draw the pixels. This was because we underestimated our ability to make a memory and VGA display for the start and end screens within the short amount of time we were given. However, during the second week of our design process, we found out that we were able to add more bits to each channel to make the design more aesthetically pleasing. 

We also learned that we need to do enough research and figure out what we really need at the early stage of the project. Our design required keyboard to take in the user’s input, and the source code was given online. The initial search led us to buy the mini ps2 version, which we thought should work the same as the original version. When we tested the code, however, it did not work as we expected and showed something different on both the FPGA board and display. After testing the code in design center, we found out that the mini version works in a different way. This prompted us to pay attention to every little detail and do enough research before using a new tool since every tiny mistake may cause a huge problem in the long run. 


### 5.0 Appendix
Appendix A: vga_inputs module

The vga_inputs module (Figure 8) consists of a finite state machine(Figure 9), which is responsible for manipulating the datapath once instructions are received from players, and a datapath, that stores the current progress of the game and produces a set of outputs based on the current state. The Information stored in datapath is current cursor position, previous cursor position, current board colour, start, end, and instruction display.
 
<p align="center">Figure 8. vga_inputs module
</p>
 
<p align="center">Figure 9. FSM for vga_inputs module
</p>  
  
Appendix B: bgm_inputs module

The bgm_inputs module(Figure 10) is responsible for generating a 32-bit sound output as the go key is pressed by the player. The source file is analyzed and resampled at 2400Hz using MATLAB and a memory initialization file is created to initialize a memory block on the chip. Upon receiving the go signal, the finite state machine(Figure 11) in this module allows the address counter in the datapath to loop through the samples at a certain frequency. The output is then connected to the audio controller to produce the background music.

<p align="center">Figure 10. bgm_inputs module
</p> 
 
<p align="center">Figure 11. FSM for bgm_inputs module
</p>

Appendix C: SE_inputs module

The SE_inputs module(Figure 12) consists of a control module, that receives a go signal, and a datapath, that produces a 32-bit sound output. Receiving the five input signals, the module first combines them into a go signal and then feed it into the finite state machine(Figure 13). After that, the control enables the address counter in datapath which loop through the samples of the source file stored in a memory block. Eventually, these samples are fed into the audio controller that produces different voltages based on the input signals.
 
<p align="center">Figure 12. SE_inputs module
</p>
 
<p align="center">Figure 13.  FSM for SE_inputs module
</p>
